<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crypto Miner Tycoon - Optimized</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <style>
        html, body { height: 100%; margin: 0; padding: 0; font-family: 'Inter', sans-serif; }
        body { display: flex; flex-direction: column; background-color: #111827; color: #d1d5db; overflow: hidden; }
        header { background-color: #1f2937; padding: 0.5rem; box-shadow: 0 1px 3px 0 rgba(0,0,0,.1), 0 1px 2px 0 rgba(0,0,0,.06); display: flex; justify-content: space-around; align-items: center; flex-shrink: 0; height: 72px; flex-wrap: nowrap; }
        header > div { text-align: center; padding: 0 0.5rem; }
        header .stat-label { font-size: .65rem; color: #9ca3af; display: block; line-height: 1.1;}
        header .stat-value { font-weight: 700; font-size: .9rem; line-height: 1.2; margin-top: 1px;}
        header .stat-unit { font-size: .65rem; }
        header .warning-text { font-weight: 500; font-size: .65rem; }
        #main-content-wrapper { display: flex; flex-direction: row; flex-grow: 1; height: calc(100% - 72px); overflow: hidden; }
        #left-panel { flex-grow: 1; height: 100%; position: relative; overflow: hidden; background-color: #374151; }
        #canvas-container { width: 100%; height: 100%; }
        #right-panel { width: 360px; height: 100%; display: flex; flex-direction: column; background-color: #1f2937; border-left: 1px solid #4b5563; overflow-y: auto; flex-shrink: 0;}
        #right-panel > section { background-color: #374151; margin: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.2), 0 1px 2px 0 rgba(0, 0, 0, 0.1); flex-shrink: 0; }
        #log-section { flex-grow: 1; display: flex; flex-direction: column; min-height: 100px; }
        #log-area { flex-grow: 1; overflow-y: auto; font-size: 0.75rem; padding-right: 4px; }
        #right-panel::-webkit-scrollbar, #log-area::-webkit-scrollbar { display: none; }
        #right-panel, #log-area { -ms-overflow-style: none; scrollbar-width: none; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #xp-bar-container { background-color: #4b5563; border-radius: 9999px; overflow: hidden; height: 8px; margin-top: 2px; }
        #xp-bar { height: 100%; width: 0%; background: linear-gradient(to right, #34d399, #2dd4bf); transition: width 0.5s ease; border-radius: 9999px; }
        #temp-bar-container { background-color: #4b5563; border-radius: 0.25rem; overflow: hidden; height: 10px; margin-top: 4px; }
        #temp-bar { height: 100%; width: 0%; background-color: #34d399; transition: width 0.5s ease, background-color 0.5s ease; border-radius: 0.25rem; }
        .temp-cool { color: #60a5fa; } .temp-warm { color: #fbbf24; } .temp-hot { color: #f87171; } .temp-overheat { color: #ef4444; font-weight: bold; animation: blink 1s linear infinite;} @keyframes blink { 50% { opacity: 0.5; } }
        .price-up { color: #10b981; } .price-down { color: #ef4444; } .price-stable { color: #6b7280; }
        .contract-progress { background-color: #4b5563; border-radius: 0.25rem; overflow: hidden; height: 6px; margin-top: 2px; } .contract-progress-bar { height: 100%; width: 0%; background-color: #a78bfa; transition: width 0.5s ease; border-radius: 0.25rem;} .event-active { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; } @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .7; } }
        .tippy-box[data-theme~='custom'] { background-color: #1f2937; color: #d1d5db; border: 1px solid #4b5563; font-size: 0.75rem; } .tippy-arrow[data-theme~='custom'] { color: #1f2937; }
        #loading-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #cbd5e0; text-align: center; font-size: 1.1em; z-index: 10; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top-color: #60a5fa; width: 40px; height: 40px; animation: spin 1s ease-in-out infinite; margin: 0 auto 10px auto; }
        @keyframes spin { to { transform: rotate(360deg); } }
        #rotate-device-message { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(17, 24, 39, 0.95); color: white; z-index: 9999; justify-content: center; align-items: center; text-align: center; padding: 20px; font-size: 1.2em; }
        @media (orientation: portrait) and (max-width: 768px) { #rotate-device-message { display: flex; } header, #main-content-wrapper { display: none; } body { overflow: hidden; } }
        @media (max-width: 768px) { @media (orientation: landscape){ header { flex-wrap: nowrap; } } @media (orientation: portrait){ body { overflow-y: auto; height: auto; } header { height: auto; flex-wrap: wrap; padding: 0.5rem 0.25rem; justify-content: space-evenly; } header > div { margin-bottom: 0.25rem; } #main-content-wrapper { flex-direction: column; height: auto; } #left-panel { flex-grow: 0; width: 100%; height: 40vh; min-height: 250px; max-height: 350px; } #right-panel { flex-grow: 1; width: 100%; height: auto; max-height: none; border-left: none; border-top: 2px solid #4b5563; } #upgrade-section button span.component-name { font-size: 10px; } #upgrade-section button span.text-xs { font-size: 11px; } } }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
     <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="text-gray-100">

    <div id="rotate-device-message">
        <p>Untuk pengalaman terbaik,<br>mohon putar perangkat Anda ke mode landscape.</p>
    </div>

     <header>
         <div class="px-1"><span class="stat-label">⭐ Level</span><span id="player-level" class="stat-value text-cyan-400">1</span><div id="xp-bar-container"><div id="xp-bar"></div></div><span id="player-xp-text" class="text-[10px] text-gray-500">0/100 XP</span></div>
         <div class="border-l border-gray-600 px-2"><span class="stat-label">💰 Uang</span><span id="uang-virtual" class="stat-value text-yellow-400">0</span></div>
         <div class="border-l border-gray-600 px-2 text-xs"><span class="stat-label">⛏️ Kripto</span><div class="flex justify-center space-x-2 mt-1"><div><span class="font-bold text-orange-400" id="mined-btc">0.00</span><span class="text-gray-400">BTC</span></div><div><span class="font-bold text-blue-400" id="mined-eth">0.00</span><span class="text-gray-400">ETH</span></div><div><span class="font-bold text-yellow-500" id="mined-doge">0.00</span><span class="text-gray-400">DOGE</span></div></div></div>
         <div class="border-l border-r border-gray-600 px-2 flex space-x-2"><div><span class="stat-label">⚙️ Tech</span><span id="tech-coin" class="stat-value text-sky-400">0</span></div><div><span class="stat-label">💎 Rare</span><span id="rare-coin" class="stat-value text-fuchsia-400">0</span></div></div>
         <div class="border-r border-gray-600 px-2"><span class="stat-label">⚡ Hashrate</span><span id="total-hashrate" class="stat-value">0</span><span class="stat-unit">H/s</span></div>
         <div class="px-1"><span class="stat-label">🌡️ Suhu CPU</span><span id="suhu-cpu" class="stat-value temp-cool">25</span><span class="stat-unit">°C</span><div id="temp-bar-container"><div id="temp-bar"></div></div></div>
         <div class="border-l border-gray-600 pl-2 pr-1"><span class="stat-label">🔌 Daya</span><span id="total-power" class="stat-value">0</span><span class="stat-unit">/</span><span id="max-power" class="stat-value text-gray-300">300</span><span class="stat-unit">W</span><div id="electricity-cost" class="text-[10px] text-red-400">Cost: $0.00/s</div></div>
         <div class="flex flex-col items-start pl-1 text-center"><div id="active-event" class="text-xs font-semibold text-lime-400 event-active" style="display: none;">EVENT!</div><div id="power-warning" class="warning-text text-red-500" style="display: none;">⚡OVERLOAD!</div><div id="throttling-status" class="warning-text text-red-500" style="display: none;">🔥OVERHEAT!</div></div>
     </header>

    <div id="main-content-wrapper">
        <div id="left-panel">
            <div id="canvas-container">
                 <div id="loading-indicator">
                     <div class="spinner"></div>
                     Memuat Aset 3D...
                 </div>
            </div>
        </div>

        <aside id="right-panel">
             <section id="market-section"> <h3 class="text-md font-semibold mb-2 text-teal-300 border-b border-gray-600 pb-1">Pasar Kripto</h3> <div class="space-y-2 text-sm"> <div class="flex justify-between items-center"><span>BTC Rate:</span><span class="font-semibold text-orange-400">$<span id="rate-btc">50000</span><span id="trend-btc" class="ml-1 price-stable">→</span></span><button onclick="exchangeCrypto('btc')" class="ml-2 px-2 py-0.5 text-xs bg-orange-500 hover:bg-orange-600 rounded disabled:bg-gray-500 exchange-btn">Tukar</button></div> <div class="flex justify-between items-center"><span>ETH Rate:</span><span class="font-semibold text-blue-400">$<span id="rate-eth">3000</span><span id="trend-eth" class="ml-1 price-stable">→</span></span><button onclick="exchangeCrypto('eth')" class="ml-2 px-2 py-0.5 text-xs bg-blue-500 hover:bg-blue-600 rounded disabled:bg-gray-500 exchange-btn">Tukar</button></div> <div class="flex justify-between items-center"><span>DOGE Rate:</span><span class="font-semibold text-yellow-500">$<span id="rate-doge">0.15</span><span id="trend-doge" class="ml-1 price-stable">→</span></span><button onclick="exchangeCrypto('doge')" class="ml-2 px-2 py-0.5 text-xs bg-yellow-500 hover:bg-yellow-600 rounded disabled:bg-gray-500 exchange-btn">Tukar</button></div> </div> </section>
             <section id="upgrade-overclock-section"> <h3 class="text-md font-semibold mb-3 text-teal-300 border-b border-gray-600 pb-1">Upgrade & Overclock</h3> <div class="grid grid-cols-2 gap-3 mb-3"> <button id="upgrade-cpu" data-tippy-content="Upgrade ke: ?" class="bg-teal-600 hover:bg-teal-700 text-white font-bold p-2 rounded-lg shadow text-xs transition duration-150 ease-in-out disabled:bg-gray-500 flex flex-col items-center justify-center h-16"><span class="block text-center text-[11px] leading-tight component-name">CPU Name (Lvl 1)</span><span class="mt-1 text-yellow-300 block text-xs">$<span id="biaya-cpu">100</span></span></button> <button id="upgrade-gpu" data-tippy-content="Upgrade ke: ?" class="bg-teal-600 hover:bg-teal-700 text-white font-bold p-2 rounded-lg shadow text-xs transition duration-150 ease-in-out disabled:bg-gray-500 flex flex-col items-center justify-center h-16"><span class="block text-center text-[11px] leading-tight component-name">GPU Name (Lvl 1)</span><span class="mt-1 text-yellow-300 block text-xs">$<span id="biaya-gpu">150</span></span></button> <button id="upgrade-pendingin" data-tippy-content="Upgrade ke: ?" class="bg-blue-600 hover:bg-blue-700 text-white font-bold p-2 rounded-lg shadow text-xs transition duration-150 ease-in-out disabled:bg-gray-500 flex flex-col items-center justify-center h-16"><span class="block text-center text-[11px] leading-tight component-name">Cooler Name (Lvl 1)</span><span class="mt-1 text-yellow-300 block text-xs">$<span id="biaya-pendingin">80</span></span></button> <button id="upgrade-psu" data-tippy-content="Upgrade ke: ?" class="bg-purple-600 hover:bg-purple-700 text-white font-bold p-2 rounded-lg shadow text-xs transition duration-150 ease-in-out disabled:bg-gray-500 flex flex-col items-center justify-center h-16"><span class="block text-center text-[11px] leading-tight component-name">PSU Name (Lvl 1)</span><span class="mt-1 text-yellow-300 block text-xs">$<span id="biaya-psu">120</span></span></button> </div> <div class="flex space-x-2"> <button id="overclock-cpu" onclick="toggleOverclock('cpu')" class="flex-1 bg-red-600 hover:bg-red-700 text-white text-xs font-bold p-1 rounded disabled:bg-gray-500">OC CPU</button> <button id="overclock-gpu" onclick="toggleOverclock('gpu')" class="flex-1 bg-red-600 hover:bg-red-700 text-white text-xs font-bold p-1 rounded disabled:bg-gray-500">OC GPU</button> </div> <div id="overclock-status" class="text-xs text-center mt-1 text-red-400"></div> </section>
             <section id="booster-section"> <h3 class="text-md font-semibold mb-2 text-teal-300 border-b border-gray-600 pb-1">Boosters</h3> <div class="grid grid-cols-3 gap-2 text-center text-xs"> <div> <button id="activate-hashBoost" onclick="activateBooster('hashBoost')" class="w-full p-1 bg-emerald-600 hover:bg-emerald-700 rounded disabled:bg-gray-500">⚡️ Hash</button> <span class="text-gray-400">(<span id="count-hashBoost">0</span>)</span> </div> <div> <button id="activate-coolingBoost" onclick="activateBooster('coolingBoost')" class="w-full p-1 bg-sky-600 hover:bg-sky-700 rounded disabled:bg-gray-500">❄️ Cool</button> <span class="text-gray-400">(<span id="count-coolingBoost">0</span>)</span> </div> <div> <button id="activate-powerBoost" onclick="activateBooster('powerBoost')" class="w-full p-1 bg-indigo-600 hover:bg-indigo-700 rounded disabled:bg-gray-500">🔌 Power</button> <span class="text-gray-400">(<span id="count-powerBoost">0</span>)</span> </div> </div> <div id="active-boosters-status" class="text-xs text-center mt-1 text-lime-400"></div> </section>
             <section id="contract-section"> <h3 class="text-md font-semibold mb-2 text-teal-300 border-b border-gray-600 pb-1">Kontrak Aktif</h3> <div id="contract-details" class="text-xs space-y-1"> <p id="contract-desc">Tidak ada kontrak aktif.</p> <div id="contract-progress-container" class="contract-progress" style="display: none;"><div id="contract-progress-bar" class="contract-progress-bar"></div></div> <p id="contract-reward"></p> <button id="contract-claim-btn" onclick="claimContractReward()" class="mt-1 w-full text-xs bg-yellow-600 hover:bg-yellow-700 rounded p-1 disabled:bg-gray-500" disabled>Klaim Hadiah</button> </div> </section>
             <section id="achievements-section"> <h3 class="text-md font-semibold mb-2 text-teal-300 border-b border-gray-600 pb-1">Pencapaian</h3> <div class="text-xs space-y-1" id="achievements-list"> <p>Loading...</p> </div> </section>
             <section id="customize-section"> <h3 class="text-md font-semibold mb-3 text-teal-300 border-b border-gray-600 pb-1">Kustomisasi</h3><div class="text-sm mb-2">Warna Karakter:</div><div class="flex space-x-2 mb-3"><button class="w-6 h-6 rounded-full bg-blue-300 border border-gray-400" onclick="changeCharacterColor(0xADD8E6)"></button><button class="w-6 h-6 rounded-full bg-pink-300 border border-gray-400" onclick="changeCharacterColor(0xFFB6C1)"></button><button class="w-6 h-6 rounded-full bg-green-300 border border-gray-400" onclick="changeCharacterColor(0x90EE90)"></button><button class="w-6 h-6 rounded-full bg-gray-400 border border-gray-400" onclick="changeCharacterColor(0xAAAAAA)"></button></div><div class="text-sm mb-2">Warna Meja:</div><div class="flex space-x-2"><button class="w-6 h-6 rounded-full bg-yellow-700 border border-gray-400" onclick="changeDeskColor(0x8B4513)"></button><button class="w-6 h-6 rounded-full bg-gray-800 border border-gray-400" onclick="changeDeskColor(0x2F4F4F)"></button><button class="w-6 h-6 rounded-full bg-white border border-gray-400" onclick="changeDeskColor(0xFFFFFF)"></button></div></section>
             <section id="log-section"> <h3 class="text-md font-semibold mb-2 text-teal-300 border-b border-gray-600 pb-1 flex-shrink-0">Log Aktivitas</h3><div id="log-area"><p>Game dimuat. Selamat menambang!</p></div></section>
        </aside>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>

    <script>
        'use strict';

        const gameState = {
            uangVirtual: 1000, minedBTC: 0, minedETH: 0, minedDOGE: 0,
            rates: { btc: 65000, eth: 3500, doge: 0.16 }, baseRates: { btc: 65000, eth: 3500, doge: 0.16 }, lastRates: { btc: 65000, eth: 3500, doge: 0.16 },
            rateVolatility: 0.20, rateNoise: 0.04, rateTime: 0, rateUpdateInterval: 5000, lastRateUpdateTime: 0,
            inflationMultiplier: 1.0, inflationRatePerMinute: 0.004, lastInflationUpdateTime: 0,
            playerLevel: 1, playerXP: 0, xpToNextLevel: 100,
            otherCoins: { techCoin: 10, rareCoin: 1 },
            komponen: { cpu: { level: 1, suhu: 25 }, gpu: { level: 1, suhu: 25 }, pendingin: { level: 1 }, psu: { level: 1 } },
            maxTemp: 85, isThrottling: false, isPowerOverload: false,
            pendinginEffectiveness: 1, suhuAmbient: 25, hashToBtcRate: 0.0000005,
             hashDistribution: { btc: 0.6, eth: 0.3, doge: 0.1 }, hashToOtherCoinRate: { eth: 0.00001, doge: 1.0 },
            xpPerUangExchanged: 0.05,
            electricityCostPerWattSecond: 0.0000001,
            overclock: { cpu: { active: false, endTime: 0, cooldownEnd: 0 }, gpu: { active: false, endTime: 0, cooldownEnd: 0 } },
            overclockDuration: 15 * 1000, overclockCooldown: 60 * 1000, overclockMultiplier: { hashrate: 1.5, power: 1.8, heat: 2.0 },
            boosters: { hashBoost: 1, coolingBoost: 1, powerBoost: 1 }, activeBoosters: { hashBoost: null, coolingBoost: null, powerBoost: null },
            boosterConfig: { hashBoost: { duration: 5 * 60 * 1000, multiplier: 1.3 }, coolingBoost: { duration: 10 * 60 * 1000, effectivenessMultiplier: 1.5 }, powerBoost: { duration: 5 * 60 * 1000, powerMultiplier: 0.8 } },
            activeContract: null,
            achievements: { uang1k: { name: "Mulai Kaya", desc: "Dapatkan $1,000", target: 1000, achieved: false }, btcExchanged1: { name: "Trader Pemula", desc: "Tukar 0.001 BTC", target: 0.001, achieved: false}, level5: { name: "Naik Pangkat", desc: "Capai Level 5", target: 5, achieved: false }, gpuLvl5: { name: "GPU Mantap", desc: "Upgrade GPU ke Level 5", target: 5, achieved: false }, },
            statsTracked: { totalUangEarned: 0, totalBTCExchanged: 0 },
            activeEvent: null, eventChancePerSecond: 0.002, eventDuration: 60 * 1000,
            currentElectricityCostPerSecond: 0
        };

        const componentNames_15 = {
            cpu: [ "Atom Core Basic", "ByteCruncher II", "Silicon Logic C-Series", "HexaCore Starter", "Zenith Compute 5", "Quantum Leap QL-100", "NovaChip Proxima", "Aether Processor 7X", "Chronos Engine CE-3000", "Hyperion Core H9", "Galactic Mind GM-Ultra", "Singularity Chip S1", "Nebula Processing Unit (NPU)", "RiftWalker Xtreme", "Omega Vertex Prime" ],
            gpu: [ "PixelFlow Lite", "RenderMax R1", "Vector Prime V-200", "ShaderStorm SSX", "CryptoHash CH-50", "RayWeaver Pro", "Matrix Engine ME-750", "Photon Blaster PB-900X", "DeepMine DM-Elite", "TerraHash T-Rex", "VoidRender VR-Ultimate", "Quantum Graphics QG-Titan", "Celestial Forge CF-Max", "WarpDrive WD-Extreme", "Infinity Matrix IM-Omega" ],
            cooler: [ "AeroFlow Basic Fan", "CoolBreeze Tower S", "IceWind Heatsink Pro", "Arctic Chill AC-120", "Vortex Liquid V L-240", "CryoStream CS-360 Elite", "SubZero Module SZ-1", "ThermoGuard TG-X", "FrostByte Integrated Loop", "HydroChill MaxFlow", "Glacial Core GC-Pro", "Zephyr Cooling System ZCS", "Avalanche Direct Die", "Nimbus Immersion Unit", "Absolute Zero Engine AZE" ],
            psu: [ "Volt Basic 300W", "PowerBrick Bronze 550W", "StableWatt Silver 750W", "JuiceBox Gold 850W", "EnergyCore Platinum 1000W", "Ampere Reactor AR-1200 Titanium", "PowerForge PF-1600 Pro", "Electron Stream ES-Max", "Quantum Grid QG-2000", "Dynamo Engine DE-Ultra", "Fusion Power Module FPM", "Stellar Core SC-Xtreme", "PowerMatrix PM-Industrial", "Singularity Conduit SC-Omega", "Infinite Current Engine ICE" ]
        };

        function generateTierStats_15(level, type) { const names = componentNames_15[type]; const name = names[level - 1] || `${type} Lvl ${level}`; let stats = { level, name }; const cpuHashExp = 1.9; const cpuPowerExp = 1.95; const cpuHeatExp = 1.9; const gpuHashExp = 2.0; const gpuPowerExp = 2.05; const gpuHeatExp = 2.0; const coolDissipationExp = 2.25; const psuMaxPowerExp = 2.35; switch (type) { case 'cpu': stats.hashrate = Math.floor(10 * Math.pow(level, cpuHashExp)); stats.power = Math.floor(50 * Math.pow(level, cpuPowerExp)); stats.heat = Math.floor(5 * Math.pow(level, cpuHeatExp)); stats.color = new THREE.Color(`hsl(${(level/15)*300}, 70%, 60%)`).getHex(); break; case 'gpu': stats.hashrate = Math.floor(20 * Math.pow(level, gpuHashExp)); stats.power = Math.floor(100 * Math.pow(level, gpuPowerExp)); stats.heat = Math.floor(15 * Math.pow(level, gpuHeatExp)); stats.fans = Math.min(3, Math.floor(level / 4)); stats.color = new THREE.Color(`hsl(${(level/15)*300 + 40 % 360}, 60%, 50%)`).getHex(); break; case 'pendingin': stats.dissipation = parseFloat((1.0 * Math.pow(level, coolDissipationExp)).toFixed(1)); stats.color = new THREE.Color(`hsl(${(level/15)*300 + 180 % 360}, 50%, 70%)`).getHex(); break; case 'psu': stats.maxPower = Math.floor(300 * Math.pow(level, psuMaxPowerExp)); const psuColors = [0x424242, 0xcd7f32, 0xc0c0c0, 0xffd700, 0xe5e4e2, 0xb0c4de]; stats.color = psuColors[Math.min(psuColors.length - 1, Math.floor(level / 3))] || 0x333333; break; } return stats; }
        const tiers = {}; for (const type in componentNames_15) { tiers[type] = []; for (let i = 1; i <= 15; i++) { tiers[type].push(generateTierStats_15(i, type)); } }
        const hargaUpgrade = { cpu: { baseCost: 100, multiplier: 1.8 }, gpu: { baseCost: 150, multiplier: 1.9 }, pendingin: { baseCost: 80, multiplier: 1.75 }, psu: { baseCost: 120, multiplier: 1.85 } };

        let scene, camera, renderer, controls, models = {}, environmentModels = {}, gpuFans = [], aspect, frustumSize = 20; const rigBasePosition = new THREE.Vector3(0.5, 0.8, -0.5);
        let isFirstRenderDone = false;

        function calculateXPForLevel(level) { return Math.floor(100 * Math.pow(level, 1.6)); }
        function getCoinsForLevelUp(level) { return { techCoin: level * 2 + Math.floor(Math.random() * level), rareCoin: Math.floor(level / 2) + (level % 5 === 0 ? 1 : 0) }; }
        function addXP(amount) { if (amount <= 0) return; gameState.playerXP += amount; addLogMessage(`+${amount.toFixed(0)} XP`, 'xp'); while (gameState.playerXP >= gameState.xpToNextLevel) { levelUp(); } updateUI(); }
        function levelUp() { gameState.playerXP -= gameState.xpToNextLevel; gameState.playerLevel++; gameState.xpToNextLevel = calculateXPForLevel(gameState.playerLevel); const rewards = getCoinsForLevelUp(gameState.playerLevel); gameState.otherCoins.techCoin += rewards.techCoin; gameState.otherCoins.rareCoin += rewards.rareCoin; addLogMessage(`🎉 LEVEL UP! Lv ${gameState.playerLevel}!`, 'levelup'); addLogMessage(`🎁 Hadiah: ${rewards.techCoin} Tech, ${rewards.rareCoin} Rare!`, 'reward'); checkAchievements(); }
        function getCurrentTier(namaKomponen) { const level = gameState.komponen[namaKomponen].level; const tierData = tiers[namaKomponen].find(t => t.level === level); return tierData || tiers[namaKomponen][tiers[namaKomponen].length - 1]; }
        function getNextUpgradeCost(namaKomponen) { const levelSaatIni = gameState.komponen[namaKomponen].level; const maxLevel = tiers[namaKomponen].length; if (levelSaatIni >= maxLevel) return Infinity; const config = hargaUpgrade[namaKomponen]; let baseCost = config.baseCost * Math.pow(config.multiplier, levelSaatIni -1); if(gameState.activeEvent && gameState.activeEvent.type === 'COMPONENT_SALE') { baseCost *= gameState.activeEvent.effectValue; } const inflatedCost = baseCost * gameState.inflationMultiplier; return Math.ceil(inflatedCost); }
        function addLogMessage(message, type = 'info') { const logArea = document.getElementById('log-area'); if (!logArea) return; const newMessage = document.createElement('p'); newMessage.textContent = `[${new Date().toLocaleTimeString('id-ID',{ hour: '2-digit', minute: '2-digit', second:'2-digit' })}] ${message}`; let textColor = 'text-gray-300'; switch (type) { case 'success': textColor = 'text-green-400'; break; case 'warning': textColor = 'text-yellow-400'; break; case 'error': textColor = 'text-red-400'; break; case 'xp': textColor = 'text-cyan-400'; break; case 'levelup': textColor = 'text-fuchsia-400 font-bold'; break; case 'reward': textColor = 'text-lime-400'; break; case 'contract': textColor = 'text-violet-400'; break; case 'event': textColor = 'text-lime-300 font-semibold'; break; case 'achievement': textColor = 'text-amber-300'; break; } newMessage.className = textColor; logArea.appendChild(newMessage); logArea.scrollTop = logArea.scrollHeight; const maxLogs = 70; if (logArea.children.length > maxLogs) { logArea.removeChild(logArea.firstChild); } }

        function init() { console.log("Initializing Optimized..."); gameState.lastInflationUpdateTime = Date.now(); gameState.lastRateUpdateTime = Date.now(); setupThreeJS(); createEnvironmentModels(); createInitialModels(); initTooltips(); generateNewContract(); updateAchievementsUI(); updateUI(); setInterval(gameLoop, 1000); animate(); setupEventListeners(); addLogMessage("Game Loaded!"); console.log("Ready."); }
        function gameLoop() { const now = Date.now(); const deltaSeconds = 1.0; updateMarket(now); updateInflation(now); checkForEvents(now); updateGameState(deltaSeconds, now); checkContractProgress(); }
        function updateMarket(currentTime) { if (currentTime - gameState.lastRateUpdateTime >= gameState.rateUpdateInterval) { gameState.lastRateUpdateTime = currentTime; gameState.rateTime += gameState.rateUpdateInterval / 1000; const frequency = 0.05; let marketBoomMultiplier = 1.0; if(gameState.activeEvent && gameState.activeEvent.type === 'MARKET_BOOM') marketBoomMultiplier = gameState.activeEvent.effectValue; if(gameState.activeEvent && gameState.activeEvent.type === 'MARKET_CRASH') marketBoomMultiplier = gameState.activeEvent.effectValue; for (const coin in gameState.rates) { const amplitude = gameState.baseRates[coin] * gameState.rateVolatility; const noise = (Math.random() - 0.5) * 2 * gameState.baseRates[coin] * gameState.rateNoise; let newRate = gameState.baseRates[coin] + Math.sin(gameState.rateTime * frequency + (coin.length*0.1)) * amplitude + noise; newRate = Math.max(gameState.baseRates[coin] * 0.3, newRate); newRate *= marketBoomMultiplier; gameState.lastRates[coin] = gameState.rates[coin]; gameState.rates[coin] = newRate; } updateUI(); } }
        function updateInflation(currentTime) { const elapsedMinutes = (currentTime - gameState.lastInflationUpdateTime) / (1000 * 60); if (elapsedMinutes >= 1) { gameState.inflationMultiplier *= (1 + gameState.inflationRatePerMinute * elapsedMinutes); gameState.lastInflationUpdateTime = currentTime; updateUI(); } }
        function checkForEvents(currentTime) { if (gameState.activeEvent && currentTime >= gameState.activeEvent.endTime) { addLogMessage(`Event berakhir: ${gameState.activeEvent.name}`, 'event'); gameState.activeEvent = null; gameState.suhuAmbient = 25; updateUI(); } if (!gameState.activeEvent && Math.random() < gameState.eventChancePerSecond) { triggerRandomEvent(currentTime); } }
        function triggerRandomEvent(currentTime) { const possibleEvents = [ { type: 'HEATWAVE', name: 'Gelombang Panas!', effectValue: 40 }, { type: 'MARKET_BOOM', name: 'Harga Kripto Naik!', effectValue: 1.5 }, { type: 'MARKET_CRASH', name: 'Harga Kripto Anjlok!', effectValue: 0.5 }, { type: 'POWER_SURGE', name: 'Lonjakan Daya!', effect: () => {} }, { type: 'COMPONENT_SALE', name: 'Diskon Upgrade!', effectValue: 0.8 }, ]; const randomIndex = Math.floor(Math.random() * possibleEvents.length); const event = possibleEvents[randomIndex]; gameState.activeEvent = { type: event.type, name: event.name, endTime: currentTime + gameState.eventDuration, effectValue: event.effectValue || null }; if (event.type === 'HEATWAVE') gameState.suhuAmbient = event.effectValue; addLogMessage(`EVENT AKTIF: ${event.name}`, 'event'); updateUI(); }
        function updateGameState(deltaSeconds, now) { const cpuTier = getCurrentTier('cpu'); const gpuTier = getCurrentTier('gpu'); const pendinginTier = getCurrentTier('pendingin'); const psuTier = getCurrentTier('psu'); let hashMultiplier = 1.0; let coolingMultiplier = 1.0; let powerMultiplier = 1.0; for(const boostType in gameState.activeBoosters) { const booster = gameState.activeBoosters[boostType]; if (booster && now < booster.endTime) { switch(boostType) { case 'hashBoost': hashMultiplier *= gameState.boosterConfig.hashBoost.multiplier; break; case 'coolingBoost': coolingMultiplier *= gameState.boosterConfig.coolingBoost.effectivenessMultiplier; break; case 'powerBoost': powerMultiplier *= gameState.boosterConfig.powerBoost.powerMultiplier; break; } } else if (booster && now >= booster.endTime) { gameState.activeBoosters[boostType] = null; addLogMessage(`Booster ${boostType} berakhir.`, 'info'); } } let ocHashMultiplier = 1.0; let ocPowerMultiplier = 1.0; let ocHeatMultiplier = 1.0; ['cpu', 'gpu'].forEach(compType => { const oc = gameState.overclock[compType]; if (oc.active) { if (now >= oc.endTime) { oc.active = false; oc.cooldownEnd = now + gameState.overclockCooldown; addLogMessage(`${compType.toUpperCase()} OC selesai. Cooldown...`, 'info'); } else { ocHashMultiplier = gameState.overclockMultiplier.hashrate; ocPowerMultiplier = gameState.overclockMultiplier.power; ocHeatMultiplier = gameState.overclockMultiplier.heat; } } }); let totalPower = (cpuTier.power + gpuTier.power) * ocPowerMultiplier * powerMultiplier; let currentMaxPower = psuTier.maxPower; if(gameState.activeEvent && gameState.activeEvent.type === 'POWER_SURGE') { currentMaxPower *= 0.7; } gameState.isPowerOverload = totalPower > currentMaxPower; const powerWarningElement = document.getElementById('power-warning'); if (powerWarningElement) powerWarningElement.style.display = gameState.isPowerOverload ? 'block' : 'none'; if (gameState.isPowerOverload) { updateUI(0, totalPower); let deltaSuhu = (gameState.suhuAmbient - gameState.komponen.cpu.suhu) * 0.1; gameState.komponen.cpu.suhu += deltaSuhu; gameState.komponen.cpu.suhu = Math.max(gameState.suhuAmbient, gameState.komponen.cpu.suhu); return; } let totalHashrate = (cpuTier.hashrate + gpuTier.hashrate) * ocHashMultiplier * hashMultiplier; const heatGenerated = (cpuTier.heat + gpuTier.heat) * ocHeatMultiplier; let ambientTemp = gameState.suhuAmbient; if(gameState.activeEvent && gameState.activeEvent.type === 'HEATWAVE') { ambientTemp = gameState.activeEvent.effectValue || 40; } const effectiveCooling = pendinginTier.dissipation * gameState.pendinginEffectiveness * coolingMultiplier; const heatDissipated = (gameState.komponen.cpu.suhu - ambientTemp) * effectiveCooling; const deltaSuhu = (heatGenerated - heatDissipated) * 0.05; gameState.komponen.cpu.suhu += deltaSuhu; gameState.komponen.cpu.suhu = Math.max(ambientTemp, gameState.komponen.cpu.suhu); gameState.komponen.cpu.suhu = Math.min(110, gameState.komponen.cpu.suhu); const throttlingElement = document.getElementById('throttling-status'); gameState.isThrottling = gameState.komponen.cpu.suhu > gameState.maxTemp; if (throttlingElement) throttlingElement.style.display = gameState.isThrottling ? 'block' : 'none'; if (gameState.isThrottling) { const overheatFactor = (gameState.komponen.cpu.suhu - gameState.maxTemp) / 15; const throttleMultiplier = Math.max(0.1, 1 - overheatFactor); totalHashrate *= throttleMultiplier; } gameState.minedBTC += totalHashrate * gameState.hashDistribution.btc * gameState.hashToBtcRate * deltaSeconds; gameState.minedETH += totalHashrate * gameState.hashDistribution.eth * gameState.hashToOtherCoinRate.eth * deltaSeconds; gameState.minedDOGE += totalHashrate * gameState.hashDistribution.doge * gameState.hashToOtherCoinRate.doge * deltaSeconds; const electricityCost = totalPower * gameState.electricityCostPerWattSecond * deltaSeconds; gameState.uangVirtual -= electricityCost; gameState.currentElectricityCostPerSecond = electricityCost / deltaSeconds; updateUI(totalHashrate, totalPower); }
        function exchangeCrypto(coinType) { let amountToExchange = 0; let rate = 0; let coinKey = ''; switch(coinType.toLowerCase()) { case 'btc': amountToExchange = gameState.minedBTC; rate = gameState.rates.btc; coinKey = 'minedBTC'; break; case 'eth': amountToExchange = gameState.minedETH; rate = gameState.rates.eth; coinKey = 'minedETH'; break; case 'doge': amountToExchange = gameState.minedDOGE; rate = gameState.rates.doge; coinKey = 'minedDOGE'; break; default: addLogMessage(`Koin tidak dikenal: ${coinType}`, 'error'); return; } if (amountToExchange <= 0.00000001) { addLogMessage(`Tidak cukup ${coinType.toUpperCase()} untuk ditukar.`, 'warning'); return; } const uangGained = amountToExchange * rate; gameState[coinKey] -= amountToExchange; gameState.uangVirtual += uangGained; gameState.statsTracked.totalUangEarned += uangGained; if(coinType.toLowerCase() === 'btc') gameState.statsTracked.totalBTCExchanged += amountToExchange; addLogMessage(`+$${uangGained.toLocaleString(undefined,{maximumFractionDigits:2})} (from ${amountToExchange.toFixed(4)} ${coinType.toUpperCase()} @ $${rate.toLocaleString(undefined,{maximumFractionDigits:2})}/${coinType.toUpperCase()})`, 'success'); const xpGained = Math.floor(uangGained * gameState.xpPerUangExchanged); addXP(xpGained); checkAchievements(); updateUI(); }
        function upgradeComponent(namaKomponen) { const biayaUpgrade = getNextUpgradeCost(namaKomponen); const nextLevel = gameState.komponen[namaKomponen].level + 1; const maxLevel = tiers[namaKomponen].length; if (nextLevel > maxLevel) { addLogMessage(`${namaKomponen.toUpperCase()} MAX!`, 'warning'); return; } if (gameState.uangVirtual >= biayaUpgrade) { gameState.uangVirtual -= biayaUpgrade; gameState.komponen[namaKomponen].level = nextLevel; if (namaKomponen === 'pendingin') { gameState.pendinginEffectiveness = getCurrentTier('pendingin').dissipation; } updateComponentModel3D(namaKomponen, nextLevel); addLogMessage(`Upgrade to ${getCurrentTier(namaKomponen).name} success! (-$${biayaUpgrade.toLocaleString()})`, 'success'); checkAchievements(); updateUI(); } else { addLogMessage(`Insufficient funds ($${biayaUpgrade.toLocaleString()}).`, 'error'); } }
        function toggleOverclock(componentType) { const now = Date.now(); const oc = gameState.overclock[componentType]; const btn = document.getElementById(`overclock-${componentType}`); if (!oc.active && now >= oc.cooldownEnd) { oc.active = true; oc.endTime = now + gameState.overclockDuration; addLogMessage(`${componentType.toUpperCase()} Overclock AKTIF!`, 'warning'); btn.classList.add('animate-pulse'); } else if (oc.active) { oc.active = false; oc.cooldownEnd = now + gameState.overclockCooldown; addLogMessage(`${componentType.toUpperCase()} OC dinonaktifkan. Cooldown...`, 'info'); btn.classList.remove('animate-pulse'); } else { addLogMessage(`${componentType.toUpperCase()} OC Cooldown...`, 'info'); } updateUI(); }
        function activateBooster(boosterType) { if (gameState.boosters[boosterType] > 0) { if (gameState.activeBoosters[boosterType] && Date.now() < gameState.activeBoosters[boosterType].endTime) { addLogMessage(`Booster ${boosterType} sudah aktif!`, 'warning'); return; } gameState.boosters[boosterType]--; const config = gameState.boosterConfig[boosterType]; gameState.activeBoosters[boosterType] = { endTime: Date.now() + config.duration }; addLogMessage(`Booster ${boosterType} diaktifkan! (${config.duration / 60000}m)`, 'success'); updateUI(); } else { addLogMessage(`Booster ${boosterType} habis!`, 'error'); } }
        const contractTemplates = [ { type: "mineCoin", coin: "btc", baseTarget: 0.001, baseReward: { uang: 5000, xp: 100 } }, { type: "mineCoin", coin: "eth", baseTarget: 0.01, baseReward: { uang: 4000, xp: 80 } }, { type: "mineCoin", coin: "doge", baseTarget: 100, baseReward: { uang: 3000, xp: 60 } }, { type: "reachHashrate", baseTarget: 100, baseReward: { uang: 2000, xp: 150, techCoin: 5 } }, { type: "earnUang", baseTarget: 10000, baseReward: { xp: 200, rareCoin: 1 } }, ];
        function generateNewContract() { if (gameState.activeContract) return; const template = contractTemplates[Math.floor(Math.random() * contractTemplates.length)]; const levelMultiplier = 1 + (gameState.playerLevel / 5); let contract = { id: Date.now(), type: template.type, target: template.baseTarget * levelMultiplier, reward: {}, current: 0, completed: false }; for(const rewardType in template.baseReward) { contract.reward[rewardType] = Math.ceil(template.baseReward[rewardType] * levelMultiplier); } switch(template.type) { case "mineCoin": contract.desc = `Tambang ${contract.target.toFixed(4)} ${template.coin.toUpperCase()}`; contract.coin = template.coin; contract.current = gameState[`mined${template.coin.toUpperCase()}`] || 0; break; case "reachHashrate": contract.target = Math.ceil(contract.target / 10) * 10; contract.desc = `Capai ${contract.target.toLocaleString()} H/s`; contract.current = parseFloat(document.getElementById('total-hashrate')?.textContent || '0'); break; case "earnUang": contract.target = Math.ceil(contract.target / 100) * 100; contract.desc = `Dapatkan $${contract.target.toLocaleString()}`; contract.current = 0; contract._startUang = gameState.statsTracked.totalUangEarned; break; } gameState.activeContract = contract; addLogMessage(`Kontrak Baru: ${contract.desc}`, 'contract'); updateUI(); }
        function checkContractProgress() { const contract = gameState.activeContract; if (!contract || contract.completed) return; let progressMade = false; switch(contract.type) { case "mineCoin": let minedKey = `mined${contract.coin.toUpperCase()}`; if(gameState[minedKey] !== undefined) { contract.current = gameState[minedKey]; if (contract.current >= contract.target) { contract.completed = true; progressMade = true;} } break; case "reachHashrate": const currentHash = parseFloat(document.getElementById('total-hashrate')?.textContent || '0'); contract.current = currentHash; if (contract.current >= contract.target) { contract.completed = true; progressMade = true;} break; case "earnUang": let earnedSinceContractStart = gameState.statsTracked.totalUangEarned - contract._startUang; contract.current = earnedSinceContractStart; if (earnedSinceContractStart >= contract.target) { contract.completed = true; progressMade = true; contract.current = contract.target; } break; } if (progressMade) { addLogMessage(`Kontrak Selesai: ${contract.desc}! Klaim hadiah!`, 'success'); updateUI(); } else { updateContractProgressUI(); } }
        function claimContractReward() { const contract = gameState.activeContract; if (!contract || !contract.completed) return; let rewardText = "Hadiah:"; for (const type in contract.reward) { const amount = contract.reward[type]; if (type === 'uang') gameState.uangVirtual += amount; else if (type === 'xp') addXP(amount); else if (gameState.otherCoins[type] !== undefined) gameState.otherCoins[type] += amount; rewardText += ` ${amount.toLocaleString()} ${type}`; } addLogMessage(rewardText, 'reward'); gameState.activeContract = null; generateNewContract(); updateUI(); }
        function checkAchievements() { let achievementUnlocked = false; for (const key in gameState.achievements) { const achievement = gameState.achievements[key]; if (!achievement.achieved) { let currentProgress = 0; switch(key) { case 'uang1k': currentProgress = gameState.statsTracked.totalUangEarned; break; case 'btcExchanged1': currentProgress = gameState.statsTracked.totalBTCExchanged; break; case 'level5': currentProgress = gameState.playerLevel; break; case 'gpuLvl5': currentProgress = gameState.komponen.gpu.level; break; } if (currentProgress >= achievement.target) { achievement.achieved = true; achievementUnlocked = true; addLogMessage(`🏆 Pencapaian: ${achievement.name}!`, 'achievement'); } } } if (achievementUnlocked) updateAchievementsUI(); }
        function updateAchievementsUI() { const listElement = document.getElementById('achievements-list'); listElement.innerHTML = ''; for (const key in gameState.achievements) { const achievement = gameState.achievements[key]; const p = document.createElement('p'); p.textContent = `${achievement.achieved ? '✅' : '🔲'} ${achievement.name} (${achievement.desc})`; p.className = achievement.achieved ? 'text-green-400' : 'text-gray-400'; listElement.appendChild(p); } }
        function updateUI(currentHashrate, currentPower) { document.getElementById('player-level').textContent = gameState.playerLevel; const xpPercent = Math.min(100, (gameState.playerXP / gameState.xpToNextLevel) * 100); document.getElementById('xp-bar').style.width = `${xpPercent}%`; document.getElementById('player-xp-text').textContent = `${Math.floor(gameState.playerXP)} / ${gameState.xpToNextLevel} XP`; document.getElementById('uang-virtual').textContent = Math.floor(gameState.uangVirtual).toLocaleString(); document.getElementById('tech-coin').textContent = gameState.otherCoins.techCoin.toLocaleString(); document.getElementById('rare-coin').textContent = gameState.otherCoins.rareCoin.toLocaleString(); document.getElementById('mined-btc').textContent = gameState.minedBTC.toFixed(3); document.getElementById('mined-eth').textContent = gameState.minedETH.toFixed(3); document.getElementById('mined-doge').textContent = gameState.minedDOGE.toFixed(1); const actualHashrate = currentHashrate !== undefined ? currentHashrate : (getCurrentTier('cpu').hashrate + getCurrentTier('gpu').hashrate); document.getElementById('total-hashrate').textContent = actualHashrate.toFixed(1); const actualPower = currentPower !== undefined ? currentPower : (getCurrentTier('cpu').power + getCurrentTier('gpu').power); document.getElementById('total-power').textContent = actualPower.toFixed(0); document.getElementById('max-power').textContent = getCurrentTier('psu').maxPower.toLocaleString(); const tempElement = document.getElementById('suhu-cpu'); const tempBar = document.getElementById('temp-bar'); const currentTemp = gameState.komponen.cpu.suhu; tempElement.textContent = currentTemp.toFixed(1); tempElement.className = 'stat-value '; if (currentTemp > gameState.maxTemp + 5) tempElement.classList.add('temp-overheat'); else if (currentTemp > gameState.maxTemp * 0.85) tempElement.classList.add('temp-hot'); else if (currentTemp > gameState.maxTemp * 0.6) tempElement.classList.add('temp-warm'); else tempElement.classList.add('temp-cool'); const tempPercent = Math.min(100, (currentTemp / (gameState.maxTemp + 10)) * 100); tempBar.style.width = `${tempPercent}%`; if (currentTemp > gameState.maxTemp) tempBar.style.backgroundColor = '#ef4444'; else if (currentTemp > gameState.maxTemp * 0.8) tempBar.style.backgroundColor = '#f87171'; else if (currentTemp > gameState.maxTemp * 0.6) tempBar.style.backgroundColor = '#fbbf24'; else tempBar.style.backgroundColor = '#34d399'; const costElement = document.getElementById('electricity-cost'); if(costElement) costElement.textContent = `Cost: $${(gameState.currentElectricityCostPerSecond || 0).toFixed(4)}/s`; for (const coin in gameState.rates) { const rateElement = document.getElementById(`rate-${coin}`); const trendElement = document.getElementById(`trend-${coin}`); if (rateElement) rateElement.textContent = gameState.rates[coin].toLocaleString(undefined, {maximumFractionDigits: coin === 'doge' ? 4 : 0}); if (trendElement) { trendElement.className = 'ml-1'; if (gameState.rates[coin] > gameState.lastRates[coin]) { trendElement.textContent = '↑'; trendElement.classList.add('price-up'); } else if (gameState.rates[coin] < gameState.lastRates[coin]) { trendElement.textContent = '↓'; trendElement.classList.add('price-down'); } else { trendElement.textContent = '→'; trendElement.classList.add('price-stable'); } } const exchangeBtn = document.querySelector(`button[onclick="exchangeCrypto('${coin}')"]`); if(exchangeBtn) exchangeBtn.disabled = gameState[`mined${coin.toUpperCase()}`] < 0.00000001; } ['cpu', 'gpu', 'pendingin', 'psu'].forEach(comp => { const btn = document.getElementById(`upgrade-${comp}`); const level = gameState.komponen[comp].level; const maxLevel = tiers[comp].length; const currentTierInfo = tiers[comp][level - 1] || tiers[comp][maxLevel - 1]; const nameSpan = btn.querySelector('.component-name'); const costSpan = btn.querySelector('#biaya-' + comp); nameSpan.textContent = `${currentTierInfo.name} (Lvl ${level})`; if (level < maxLevel) { const biaya = getNextUpgradeCost(comp); if (costSpan) costSpan.textContent = biaya.toLocaleString(); btn.disabled = gameState.uangVirtual < biaya; const nextTierInfo = tiers[comp][level]; if (nextTierInfo) { btn._tippy?.setContent(`Upgrade ke: ${nextTierInfo.name} ($${biaya.toLocaleString()})`); } } else { nameSpan.textContent = `${currentTierInfo.name} (MAX)`; if (costSpan) costSpan.textContent = "MAX"; btn.disabled = true; btn._tippy?.setContent(`${currentTierInfo.name} (Level Maksimum)`); } }); const now = Date.now(); let ocStatusText = ''; ['cpu', 'gpu'].forEach(compType => { const oc = gameState.overclock[compType]; const btn = document.getElementById(`overclock-${compType}`); btn.disabled = oc.cooldownEnd > now; btn.classList.toggle('animate-pulse', oc.active); if (oc.active) { ocStatusText += `${compType.toUpperCase()} OC (${Math.ceil((oc.endTime - now)/1000)}s) `; } else if (oc.cooldownEnd > now) { ocStatusText += `${compType.toUpperCase()} CD (${Math.ceil((oc.cooldownEnd - now)/1000)}s) `; } }); document.getElementById('overclock-status').textContent = ocStatusText; let activeBoostText = ''; for(const boostType in gameState.boosters) { document.getElementById(`count-${boostType}`).textContent = gameState.boosters[boostType]; document.getElementById(`activate-${boostType}`).disabled = gameState.boosters[boostType] <= 0 || (gameState.activeBoosters[boostType] && now < gameState.activeBoosters[boostType].endTime); if (gameState.activeBoosters[boostType] && now < gameState.activeBoosters[boostType].endTime) { activeBoostText += `${boostType}(${Math.ceil((gameState.activeBoosters[boostType].endTime - now)/60000)}m) `; } } document.getElementById('active-boosters-status').textContent = activeBoostText; updateContractProgressUI(); const claimBtn = document.getElementById('contract-claim-btn'); if(gameState.activeContract) claimBtn.disabled = !gameState.activeContract.completed; else claimBtn.disabled = true; const eventElement = document.getElementById('active-event'); if (gameState.activeEvent) { eventElement.textContent = `EVENT: ${gameState.activeEvent.name} (${Math.ceil((gameState.activeEvent.endTime - now)/1000)}s)`; eventElement.style.display = 'block'; } else { eventElement.style.display = 'none'; } }
        function updateContractProgressUI() { const contract = gameState.activeContract; const descEl = document.getElementById('contract-desc'); const rewardEl = document.getElementById('contract-reward'); const progressContainer = document.getElementById('contract-progress-container'); const progressBar = document.getElementById('contract-progress-bar'); if (contract) { let currentValStr = contract.current.toLocaleString(undefined,{maximumFractionDigits: contract.type === 'mineCoin' ? 4:0}); let targetValStr = contract.target.toLocaleString(undefined,{maximumFractionDigits: contract.type === 'mineCoin' ? 4:0}); descEl.textContent = `${contract.desc} (${currentValStr}/${targetValStr})`; let rewardText = "Hadiah: "; for(const type in contract.reward) { rewardText += `${contract.reward[type].toLocaleString()} ${type}, `; } rewardEl.textContent = rewardText.slice(0, -2); if (!contract.completed) { const progress = Math.min(100, (contract.current / contract.target) * 100); progressBar.style.width = `${progress}%`; progressContainer.style.display = 'block'; } else { progressBar.style.width = '100%'; progressContainer.style.display = 'block'; descEl.textContent = `${contract.desc} (Selesai!)`; } } else { descEl.textContent = "Tidak ada kontrak aktif."; rewardEl.textContent = ""; progressContainer.style.display = 'none'; } }

        function setupThreeJS() { const container = document.getElementById('canvas-container'); if (!container) return; scene = new THREE.Scene(); scene.background = new THREE.Color(0x1f2937); aspect = container.clientWidth / container.clientHeight; frustumSize = 20; camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 1000); const camDistance = 19; camera.position.set(camDistance, camDistance * 0.9, camDistance); const lookAtPosition = new THREE.Vector3(0, 1.0, -0.5); camera.lookAt(lookAtPosition); camera.updateProjectionMatrix(); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(container.clientWidth, container.clientHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; container.appendChild(renderer.domElement); const ambientLight = new THREE.AmbientLight(0xcccccc, 0.7); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); directionalLight.position.set(20, 30, 20); directionalLight.target.position.copy(lookAtPosition); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024; directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 100; directionalLight.shadow.camera.left = -frustumSize; directionalLight.shadow.camera.right = frustumSize; directionalLight.shadow.camera.top = frustumSize; directionalLight.shadow.camera.bottom = -frustumSize; scene.add(directionalLight); scene.add(directionalLight.target); controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = true; controls.target.copy(lookAtPosition); controls.maxPolarAngle = Math.PI / 1.9; controls.minZoom = 0.4; controls.maxZoom = 3; controls.update(); window.addEventListener('resize', onWindowResize, false); }
        function createEnvironmentModels() { const floorSize = 25; const floorGeo = new THREE.PlaneGeometry(floorSize, floorSize); const floorMat = new THREE.MeshStandardMaterial({ color: 0x44444f, roughness: 0.8 }); const floor = new THREE.Mesh(floorGeo, floorMat); floor.rotation.x = -Math.PI / 2; floor.position.y = 0; floor.receiveShadow = true; scene.add(floor); const wallHeight = 10; const wallThickness = 0.2; const wallMat = new THREE.MeshStandardMaterial({ color: 0x374151, roughness: 0.9 }); const wallBackGeo = new THREE.BoxGeometry(floorSize + wallThickness, wallHeight, wallThickness); const wallLeftGeo = new THREE.BoxGeometry(wallThickness, wallHeight, floorSize + wallThickness); const wallBack = new THREE.Mesh(wallBackGeo, wallMat); const wallLeft = new THREE.Mesh(wallLeftGeo, wallMat); wallBack.position.set(0, wallHeight / 2, -floorSize / 2); wallLeft.position.set(-floorSize / 2, wallHeight / 2, 0); wallBack.receiveShadow = true; wallLeft.receiveShadow = true; scene.add(wallBack); scene.add(wallLeft); const deskHeight = 0.8; const deskWidth = 4; const deskDepth = 2; const deskGeo = new THREE.BoxGeometry(deskWidth, deskHeight, deskDepth); const deskMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.7, metalness: 0.1 }); const desk = new THREE.Mesh(deskGeo, deskMat); desk.position.y = deskHeight / 2; desk.castShadow = true; desk.receiveShadow = true; scene.add(desk); environmentModels['desk'] = desk; const chairSeatGeo = new THREE.BoxGeometry(1, 0.2, 1); const chairBackGeo = new THREE.BoxGeometry(1, 1.2, 0.2); const chairLegGeo = new THREE.CylinderGeometry(0.05, 0.05, deskHeight * 0.5, 8); const chairMat = new THREE.MeshStandardMaterial({ color: 0x404040, roughness: 0.7 }); const chairGroup = new THREE.Group(); const chairSeat = new THREE.Mesh(chairSeatGeo, chairMat); const chairBack = new THREE.Mesh(chairBackGeo, chairMat); chairSeat.position.y = deskHeight * 0.5 + 0.2/2; chairBack.position.set(0, chairSeat.position.y + 1.2 / 2 - 0.1, -1/2 + 0.2/2); for (let i = 0; i < 4; i++) { const leg = new THREE.Mesh(chairLegGeo, chairMat); leg.position.set((i % 2 === 0 ? -0.4 : 0.4), deskHeight * 0.25, (i < 2 ? -0.4 : 0.4)); chairGroup.add(leg); } chairGroup.add(chairSeat); chairGroup.add(chairBack); chairGroup.position.set(0, 0, deskDepth / 2 + 0.6); chairGroup.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } }); scene.add(chairGroup); environmentModels['chair'] = chairGroup; const charBodyGeo = new THREE.BoxGeometry(0.6, 0.9, 0.5); const charHeadGeo = new THREE.SphereGeometry(0.3, 16, 16); const charBodyMat = new THREE.MeshStandardMaterial({ color: 0xADD8E6 }); const charHeadMat = new THREE.MeshStandardMaterial({ color: 0xADD8E6 }); const charBody = new THREE.Mesh(charBodyGeo, charBodyMat); const charHead = new THREE.Mesh(charHeadGeo, charHeadMat); charBody.position.set(0, deskHeight * 0.5 + 0.2/2 + 0.9/2, 0); charHead.position.set(0, charBody.position.y + 0.9/2 + 0.3, 0); charBody.castShadow = true; charHead.castShadow = true; chairGroup.add(charBody); chairGroup.add(charHead); environmentModels['characterBody'] = charBody; environmentModels['characterHead'] = charHead; const monitorScreenGeo = new THREE.BoxGeometry(1.5, 0.9, 0.1); const monitorStandGeo = new THREE.BoxGeometry(0.3, 0.2, 0.3); const monitorMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2 }); const monitorScreen = new THREE.Mesh(monitorScreenGeo, monitorMat); const monitorStand = new THREE.Mesh(monitorStandGeo, monitorMat); monitorStand.position.set(0, deskHeight + 0.2/2, -deskDepth / 2 + 0.5); monitorScreen.position.set(monitorStand.position.x, monitorStand.position.y + 0.2/2 + 0.9/2, monitorStand.position.z); monitorScreen.castShadow = true; monitorScreen.receiveShadow = true; monitorStand.castShadow = true; monitorStand.receiveShadow = true; scene.add(monitorStand); scene.add(monitorScreen); environmentModels['monitorScreen'] = monitorScreen; environmentModels['monitorStand'] = monitorStand; const keybGeo = new THREE.BoxGeometry(1.2, 0.05, 0.4); const keybMat = new THREE.MeshStandardMaterial({color: 0x222222}); const keyboard = new THREE.Mesh(keybGeo, keybMat); keyboard.position.set(0, deskHeight + 0.05/2, 0.3); keyboard.castShadow = true; scene.add(keyboard); environmentModels['keyboard'] = keyboard; const mouseGeo = new THREE.BoxGeometry(0.15, 0.06, 0.25); const mouseMat = new THREE.MeshStandardMaterial({color: 0x252525}); const mouse = new THREE.Mesh(mouseGeo, mouseMat); mouse.position.set(0.8, deskHeight + 0.06/2, 0.3); mouse.castShadow = true; scene.add(mouse); environmentModels['mouse'] = mouse; rigBasePosition.y = deskHeight; }
        function createInitialModels() { const moboWidth = 1.8; const moboDepth = 1.2; const moboGeo = new THREE.BoxGeometry(moboWidth, 0.05, moboDepth); const moboMat = new THREE.MeshStandardMaterial({ color: 0x005540, roughness: 0.6 }); const motherboard = new THREE.Mesh(moboGeo, moboMat); motherboard.position.set(rigBasePosition.x, rigBasePosition.y + 0.05 / 2, rigBasePosition.z); motherboard.castShadow = true; motherboard.receiveShadow = true; scene.add(motherboard); models['motherboard'] = motherboard; updateComponentModel3D('cpu', gameState.komponen.cpu.level); updateComponentModel3D('gpu', gameState.komponen.gpu.level); updateComponentModel3D('pendingin', gameState.komponen.pendingin.level); updateComponentModel3D('psu', gameState.komponen.psu.level); }
        function updateComponentModel3D(namaKomponen, levelBaru) { if (!models['motherboard']) return; const moboPos = models['motherboard'].position; const moboTopY = moboPos.y + 0.05 / 2; if (models[namaKomponen]) { scene.remove(models[namaKomponen]); models[namaKomponen].traverse(child => { if (child.isMesh) { if (child.geometry) child.geometry.dispose(); if (child.material) { if (Array.isArray(child.material)) { child.material.forEach(m => m.dispose()); } else { child.material.dispose(); } } } }); delete models[namaKomponen]; } if (namaKomponen === 'gpu') { gpuFans = []; } const tierData = tiers[namaKomponen][levelBaru - 1] || tiers[namaKomponen][tiers[namaKomponen].length - 1]; let componentGroup = new THREE.Group(); let position = { x: moboPos.x, y: moboTopY, z: moboPos.z }; const scale = 0.18; switch (namaKomponen) { case 'cpu': const cpuSize = scale * (1 + (levelBaru - 1) * 0.08); const cpuGeo = new THREE.BoxGeometry(cpuSize, 0.1, cpuSize); const cpuMat = new THREE.MeshStandardMaterial({ color: tierData.color, roughness: 0.6 }); const cpuMesh = new THREE.Mesh(cpuGeo, cpuMat); cpuMesh.position.y = 0.1 / 2; componentGroup.add(cpuMesh); position.z += 0.25; break; case 'gpu': const gpuLength = 0.8 * (1 + (levelBaru - 1) * 0.12); const gpuHeight = 0.25 * (1 + (levelBaru - 1) * 0.03); const gpuWidth = 0.18; const gpuBodyGeo = new THREE.BoxGeometry(gpuWidth, gpuHeight, gpuLength); const gpuMat = new THREE.MeshStandardMaterial({ color: tierData.color, metalness: 0.2, roughness: 0.5 }); const gpuBody = new THREE.Mesh(gpuBodyGeo, gpuMat); gpuBody.position.y = gpuHeight / 2; componentGroup.add(gpuBody); if (tierData.fans > 0) { const fanRadius = gpuHeight * 0.4; const fanGeo = new THREE.CylinderGeometry(fanRadius, fanRadius, 0.05, 16); const fanMat = new THREE.MeshStandardMaterial({ color: 0x111111 }); for (let i = 0; i < tierData.fans; i++) { const fan = new THREE.Mesh(fanGeo, fanMat); fan.rotation.z = Math.PI / 2; fan.position.set(gpuWidth/2 + 0.025, gpuBody.position.y, (gpuLength / (tierData.fans + 1)) * (i + 1) - gpuLength/2); componentGroup.add(fan); gpuFans.push(fan); } } componentGroup.rotation.y = Math.PI / 2; position.z -= 0.3; break; case 'pendingin': if (models['cpu']) { const cpuModel = models['cpu'].children[0]; const cpuTopY = cpuModel.position.y + 0.1 / 2; let coolerHeight = 0; const coolerBaseSize = scale * 1.1 * (1 + (levelBaru-1)*0.05); const coolerMat = new THREE.MeshStandardMaterial({ color: tierData.color, metalness: 0.3, roughness: 0.4 }); if (levelBaru <= 8) { coolerHeight = 0.3 + (levelBaru - 1) * 0.08; const coolerGeo = new THREE.BoxGeometry(coolerBaseSize, coolerHeight, coolerBaseSize * 0.8); const coolerMesh = new THREE.Mesh(coolerGeo, coolerMat); coolerMesh.position.y = cpuTopY + coolerHeight / 2; componentGroup.add(coolerMesh); const finHeight = coolerHeight * 0.8; const finGeo = new THREE.BoxGeometry(coolerBaseSize * 1.1, finHeight, 0.02); const finMat = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, metalness: 0.7 }); const finCount = Math.min(10, 3 + Math.floor(levelBaru/2)); for(let i=0; i< finCount ; i++) { const fin = new THREE.Mesh(finGeo, finMat); fin.position.set(0, cpuTopY + finHeight/2 + 0.05, (i - Math.floor(finCount/2))* (coolerBaseSize*0.8 / finCount) * 0.8 ); componentGroup.add(fin); } } else { coolerHeight = 0.5 + (levelBaru - 9) * 0.05; const coolerGeo = new THREE.BoxGeometry(coolerBaseSize * 1.2, coolerHeight, coolerBaseSize * 1.2); const coolerMesh = new THREE.Mesh(coolerGeo, coolerMat); coolerMesh.position.y = cpuTopY + coolerHeight / 2; componentGroup.add(coolerMesh); } position = models['cpu'].position.clone(); } else { return; } break; case 'psu': const psuSize = scale * 2.5 * (1 + (levelBaru - 1)*0.04); const psuHeight = scale * 1.2 * (1 + (levelBaru - 1)*0.04); const psuGeo = new THREE.BoxGeometry(psuSize, psuHeight, psuSize * 1.5); const psuMat = new THREE.MeshStandardMaterial({ color: tierData.color, metalness: 0.1, roughness: 0.7 }); const psuMesh = new THREE.Mesh(psuGeo, psuMat); psuMesh.position.y = psuHeight / 2; componentGroup.add(psuMesh); position.x -= (1.8/4 + psuSize/2); position.z -= (1.2/4 + (psuSize*1.5)/2); break; default: return; } componentGroup.traverse(child => { if (child.isMesh) { child.castShadow = true; } }); componentGroup.position.set(position.x, position.y, position.z); scene.add(componentGroup); models[namaKomponen] = componentGroup; }
        function animate() { requestAnimationFrame(animate); const delta = 0.016; if (gpuFans.length > 0 && !gameState.isPowerOverload) { const rotationSpeed = gameState.isThrottling ? 1 : 4 + Math.log10(gameState.komponen.gpu.level); gpuFans.forEach(fan => { fan.rotation.y += rotationSpeed * delta * 10; }); } if (controls) controls.update(); renderer.render(scene, camera); if (!isFirstRenderDone) { isFirstRenderDone = true; const loadingIndicator = document.getElementById('loading-indicator'); if (loadingIndicator) loadingIndicator.remove(); console.log("First render complete. Removing loading indicator."); } }
        function onWindowResize() { const container = document.getElementById('canvas-container'); if (!container || !camera || !renderer) return; const width = container.clientWidth; const height = container.clientHeight; aspect = width / height; camera.left = -frustumSize * aspect / 2; camera.right = frustumSize * aspect / 2; camera.top = frustumSize / 2; camera.bottom = -frustumSize / 2; camera.updateProjectionMatrix(); renderer.setSize(width, height); }

        function changeCharacterColor(colorHex) { if (environmentModels['characterBody'] && environmentModels['characterHead']) { environmentModels['characterBody'].material.color.setHex(colorHex); environmentModels['characterHead'].material.color.setHex(colorHex); } }
        function changeDeskColor(colorHex) { if (environmentModels['desk']) { environmentModels['desk'].material.color.setHex(colorHex); } }
        function initTooltips() { tippy('[data-tippy-content]', { theme: 'custom', arrow: true, animation: 'fade', placement: 'top-start', }); }

        function setupEventListeners() { document.getElementById('upgrade-cpu').addEventListener('click', () => upgradeComponent('cpu')); document.getElementById('upgrade-gpu').addEventListener('click', () => upgradeComponent('gpu')); document.getElementById('upgrade-pendingin').addEventListener('click', () => upgradeComponent('pendingin')); document.getElementById('upgrade-psu').addEventListener('click', () => upgradeComponent('psu')); }

        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
